<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patient Monitor</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0f0;
            padding: 20px;
            line-height: 1.8;
        }

        h1 {
            color: #0ff;
            margin-bottom: 20px;
        }

        .status {
            color: #0f0;
            margin: 5px 0;
        }

        .voice-status {
            color: #ff0;
            margin: 5px 0;
            padding: 10px;
            border: 1px solid #ff0;
            background: #222;
        }

        .alert-box {
            color: #ff0000;
            background: #330000;
            padding: 20px;
            margin: 20px 0;
            border: 3px solid #ff0000;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% {
                border-color: #ff0000;
            }
            51%, 100% {
                border-color: #660000;
            }
        }

        .alert-title {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .alert-details {
            font-size: 14px;
            line-height: 1.6;
        }

        #output {
            margin-top: 20px;
        }

        .preview {
            margin-top: 20px;
            border: 1px solid #0f0;
            padding: 10px;
            border-radius: 8px;
        }

        .preview-label {
            font-size: 14px;
            margin-bottom: 8px;
            color: #0ff;
        }

        #localPreview {
            width: 100%;
            max-width: 360px;
            height: 200px;
            background: #030303;
            border: 1px solid #0f0;
            object-fit: cover;
        }

        .transcript-box {
            margin-top: 10px;
            padding: 10px;
            background: #111;
            border: 1px solid #0ff;
            min-height: 60px;
            color: #0ff;
        }
    </style>
</head>

<body>
    <h1>ğŸ¥ PATIENT MONITORING SYSTEM</h1>
    <div class="status">Patient ID: PATIENT_001</div>
    <div class="status">Status: Initializing...</div>
    <div class="voice-status">ğŸ¤ Voice Monitor: Initializing...</div>
    <div class="transcript-box" id="transcript">Listening for audio...</div>
    <div id="output"></div>
    <div class="preview">
        <div class="preview-label">Camera Preview (local device)</div>
        <video id="localPreview" autoplay muted playsinline></video>
    </div>

    <script src="https://unpkg.com/livekit-client@2.5.8/dist/livekit-client.umd.min.js"></script>
    <script type="module">
        import { RealtimeVision } from 'https://esm.sh/@overshoot/sdk';

        const output = document.getElementById('output');
        const statusEls = document.querySelectorAll('.status');
        const statusEl = statusEls[statusEls.length - 1] ?? null;
        const voiceStatusEl = document.querySelector('.voice-status');
        const transcriptEl = document.getElementById('transcript');
        const previewVideo = document.getElementById('localPreview');

        const PATIENT = {
            patientId: 'PATIENT_001',
            patientName: 'John Doe',
            roomNumber: '305',
        };

        const ALERT_COOLDOWN = 10000; // ms
        const VOICE_ALERT_COOLDOWN = 5000; // ms for voice alerts
        let vision;
        let ws;
        let lastAlertTime = 0;
        let lastVoiceAlertTime = 0;
        let heartbeatTimer;
        let cameraStream;
        let peerConnection = null;
        let currentNurseId = null;
        const pendingRemoteCandidates = [];

        // LiveKit voice monitoring variables
        let livekitRoom = null;
        let audioTrack = null;
        let isVoiceMonitorActive = false;

        // Distress keywords for voice detection
        const DISTRESS_KEYWORDS = {
            'help': 'PATIENT_DISTRESS',
            'help me': 'PATIENT_EMERGENCY',
            'emergency': 'PATIENT_EMERGENCY',
            'choking': 'CHOKING',
            'can\'t breathe': 'BREATHING_DIFFICULTY',
            'cant breathe': 'BREATHING_DIFFICULTY',
            'cannot breathe': 'BREATHING_DIFFICULTY',
            'pain': 'PAIN_ALERT',
            'hurt': 'PAIN_ALERT',
            'hurts': 'PAIN_ALERT',
            'chest pain': 'CARDIAC_ALERT',
            'heart': 'CARDIAC_ALERT',
            'falling': 'FALL_ALERT',
            'dizzy': 'DIZZINESS',
            'nurse': 'NURSE_REQUEST',
            'doctor': 'DOCTOR_REQUEST',
        };

        const DEFAULT_ICE_SERVERS = [
            {
                urls: ['stun:stun.l.google.com:19302'],
            },
            {
                urls: [
                    'turn:openrelay.metered.ca:80?transport=udp',
                    'turn:openrelay.metered.ca:443?transport=tcp',
                    'turns:openrelay.metered.ca:443?transport=tcp',
                ],
                username: 'openrelayproject',
                credential: 'openrelayproject',
            },
        ];

        const rtcConfig = buildRtcConfig();
        const httpBase = getHttpBase();
        const wsUrl = getWsUrl(httpBase);

        bootstrap().catch((err) => {
            console.error('Failed to start monitor', err);
            updateStatus('Error initializing monitor');
        });

        async function bootstrap() {
            updateStatus('Requesting camera access...');
            cameraStream = await initCameraStream();

            updateStatus('Fetching secure Overshoot config...');
            const config = await fetchOvershootConfig();

            updateStatus('Connecting to backend...');
            connectWebSocket(config);

            // Initialize voice monitoring
            await initVoiceMonitoring();
        }

        async function initVoiceMonitoring() {
            try {
                updateVoiceStatus('Requesting microphone access...');
                
                // Get microphone access
                const audioStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                    },
                    video: false
                });

                updateVoiceStatus('Connecting to LiveKit...');

                // Get LiveKit token from backend
                const tokenResponse = await fetch(`${httpBase}/api/livekit-token`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        roomName: `patient_${PATIENT.patientId}`,
                        participantName: PATIENT.patientId,
                    })
                });

                if (!tokenResponse.ok) {
                    throw new Error('Failed to get LiveKit token');
                }

                const { token, url } = await tokenResponse.json();

                // Connect to LiveKit room
                livekitRoom = new LivekitClient.Room({
                    adaptiveStream: true,
                    dynacast: true,
                });

                // Set up transcription handler
                livekitRoom.on(LivekitClient.RoomEvent.TranscriptionReceived, handleTranscription);

                await livekitRoom.connect(url, token);
                
                // Publish audio track
                audioTrack = await LivekitClient.createLocalAudioTrack({
                    source: LivekitClient.Track.Source.Microphone,
                });
                await livekitRoom.localParticipant.publishTrack(audioTrack);

                isVoiceMonitorActive = true;
                updateVoiceStatus('ğŸ¤ Voice Monitor: ACTIVE - Listening for distress');
                
                console.log('âœ… Voice monitoring active');
            } catch (error) {
                console.error('Failed to initialize voice monitoring:', error);
                updateVoiceStatus('âš ï¸ Voice Monitor: FAILED - ' + error.message);
            }
        }

        function handleTranscription(transcription) {
            // Handle both single segment and array of segments
            const segments = Array.isArray(transcription.segments) 
                ? transcription.segments 
                : [transcription];

            segments.forEach(segment => {
                const text = segment.text || segment.final || '';
                if (!text) return;

                console.log('Transcription:', text);
                updateTranscript(text);

                // Check for distress keywords
                const detection = detectDistress(text);
                if (detection.isDistress) {
                    handleVoiceDistress(detection.eventType, text, detection.keyword);
                }
            });
        }

        function detectDistress(transcript) {
            const lowerText = transcript.toLowerCase();
            
            // Check each keyword
            for (const [keyword, eventType] of Object.entries(DISTRESS_KEYWORDS)) {
                if (lowerText.includes(keyword)) {
                    return {
                        isDistress: true,
                        eventType: eventType,
                        keyword: keyword
                    };
                }
            }

            return { isDistress: false };
        }

        function handleVoiceDistress(eventType, transcript, keyword) {
            const now = Date.now();
            if (now - lastVoiceAlertTime < VOICE_ALERT_COOLDOWN) {
                return; // Cooldown to prevent spam
            }

            lastVoiceAlertTime = now;

            const alert = {
                source: 'voice',
                eventType: eventType,
                transcript: transcript,
                keyword: keyword,
                confidence: 0.9,
                urgency: eventType.includes('EMERGENCY') ? 'immediate' : 'urgent'
            };

            console.log('ğŸš¨ Voice distress detected:', alert);
            showVoiceAlert(alert);
            sendVoiceAlertToBackend(alert);
        }

        function sendVoiceAlertToBackend(alert) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                console.warn('WebSocket not ready, skipping voice alert');
                return;
            }

            ws.send(JSON.stringify({
                type: 'voice_alert',
                ...PATIENT,
                condition: alert.eventType,
                confidence: alert.confidence,
                description: `Voice distress detected: "${alert.keyword}" - ${alert.transcript}`,
                urgency: alert.urgency,
                transcript: alert.transcript,
                source: 'voice'
            }));

            console.log('ğŸš¨ Voice alert sent to backend');
        }

        function showVoiceAlert(alert) {
            const timestamp = new Date().toLocaleString();

            const alertDiv = document.createElement('div');
            alertDiv.className = 'alert-box';
            alertDiv.innerHTML = `
                <div class="alert-title">ğŸ¤ğŸš¨ VOICE ALERT - PATIENT CALLING FOR HELP ğŸš¨ğŸ¤</div>
                <div class="alert-details">
                    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•<br>
                    Patient ID:      ${PATIENT.patientId}<br>
                    Alert Type:      ${alert.eventType}<br>
                    Detected Word:   "${alert.keyword}"<br>
                    Confidence:      ${(alert.confidence * 100).toFixed(1)}%<br>
                    Urgency:         ${alert.urgency.toUpperCase()}<br>
                    Time:            ${timestamp}<br>
                    <br>
                    Patient Said:<br>
                    "${alert.transcript}"<br>
                    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•<br>
                    <br>
                    ğŸ“± Notification sent to nurse station
                </div>
            `;

            output.insertBefore(alertDiv, output.firstChild);

            setTimeout(() => {
                alertDiv.style.opacity = '0.3';
            }, 30000);
        }

        function updateTranscript(text) {
            const timestamp = new Date().toLocaleTimeString();
            transcriptEl.innerHTML = `[${timestamp}] Patient: "${text}"`;
        }

        function updateVoiceStatus(text) {
            if (voiceStatusEl) {
                voiceStatusEl.textContent = text;
            }
        }

        function connectWebSocket(config) {
            ws = new WebSocket(wsUrl);

            ws.onopen = async () => {
                updateStatus('Connected to backend. Registering patient...');
                ws.send(
                    JSON.stringify({
                        type: 'register_patient',
                        ...PATIENT,
                    })
                );

                await startVision(config);
                startHeartbeat();
                await startVideoStreaming();
            };

            ws.onclose = () => {
                stopHeartbeat();
                stopVideoStreaming();
                updateStatus('Disconnected from backend. Retrying in 3s...');
                setTimeout(() => connectWebSocket(config), 3000);
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    switch (data.type) {
                        case 'webrtc_offer':
                            handleWebRtcOffer(data);
                            break;
                        case 'webrtc_ice_candidate':
                            handleRemoteIceCandidate(data);
                            break;
                        default:
                            break;
                    }
                } catch (error) {
                    console.error('Failed to parse incoming message', error);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }

        async function fetchOvershootConfig() {
            const response = await fetch(`${httpBase}/api/overshoot-config`);

            if (!response.ok) {
                throw new Error('Unable to fetch Overshoot config');
            }

            return response.json();
        }

        async function startVision(config) {
            if (vision) {
                await vision.stop();
            }

            vision = new RealtimeVision({
                apiUrl: config.apiUrl,
                apiKey: config.apiKey,
                prompt: `You are an AI medical monitoring assistant analyzing video of a patient in real-time.

CRITICAL CONDITIONS TO DETECT:

1. CHOKING - Clutching throat, unable to breathe, distressed face, turning blue
2. SEIZURE - Convulsions, loss of consciousness, jerking movements, rigid body
3. FALL - Sudden drop in position, person on floor unexpectedly
4. DISTRESS - Heavy breathing, holding chest, pain expression, calling for help

RESPONSE FORMAT (JSON only):
If normal: {"status": "normal"}

If emergency: {
  "status": "alert",
  "condition": "CHOKING|SEIZURE|FALL|DISTRESS",
  "confidence": 0.0-1.0,
  "description": "what you see",
  "urgency": "immediate|urgent|concerning"
}`,
                source: { type: 'camera', cameraFacing: 'user' },
                outputSchema: {
                    type: 'object',
                    properties: {
                        status: { type: 'string' },
                        condition: { type: 'string' },
                        confidence: { type: 'number' },
                        description: { type: 'string' },
                        urgency: { type: 'string' },
                    },
                },
                onResult: handleVisionResult,
            });

            await vision.start();
            console.log('âœ… Monitoring active');
            updateStatus('Active - Monitoring for emergencies');
        }

        function normalizeVisionOutput(result) {
            if (!result) {
                return null;
            }

            const candidates = [
                result.output,
                result.result,
                result.payload,
            ];

            for (const candidate of candidates) {
                if (!candidate) {
                    continue;
                }

                if (typeof candidate === 'string') {
                    try {
                        return JSON.parse(candidate);
                    } catch {
                        continue;
                    }
                } else if (typeof candidate === 'object') {
                    return candidate;
                }
            }

            console.warn('RealtimeVision emitted unsupported payload', result);
            return null;
        }

        function handleVisionResult(result) {
            const analysis = normalizeVisionOutput(result);
            if (!analysis) {
                return;
            }

            const status = (analysis.status || '').toLowerCase();
            const confidence = Number(analysis.confidence || 0);

            if (['alert', 'critical', 'emergency'].includes(status) && confidence >= 0.7) {
                const now = Date.now();
                if (now - lastAlertTime < ALERT_COOLDOWN) {
                    return;
                }

                lastAlertTime = now;
                showAlert(analysis);
                sendAlertToBackend(analysis);
                return;
            }

            updateStatus('Normal - Patient stable');
        }

        function sendAlertToBackend(analysis) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                console.warn('WebSocket not ready, skipping alert broadcast');
                return;
            }

            ws.send(
                JSON.stringify({
                    type: 'alert',
                    ...PATIENT,
                    condition: analysis.condition,
                    confidence: analysis.confidence,
                    description: analysis.description,
                    urgency: analysis.urgency,
                    source: 'vision'
                })
            );

            console.log('ğŸš¨ Alert sent to backend', analysis);
        }

        function startHeartbeat() {
            heartbeatTimer = setInterval(() => {
                if (ws?.readyState === WebSocket.OPEN) {
                    ws.send(
                        JSON.stringify({
                            type: 'heartbeat',
                            patientId: PATIENT.patientId,
                        })
                    );
                }
            }, 10000);
        }

        function stopHeartbeat() {
            if (heartbeatTimer) {
                clearInterval(heartbeatTimer);
                heartbeatTimer = null;
            }
        }

        function updateStatus(text) {
            if (!statusEl) {
                console.warn('Status element missing, skipping status update');
                return;
            }

            const timestamp = new Date().toLocaleTimeString();
            statusEl.textContent = `Status: [${timestamp}] ${text}`;
        }

        function showAlert(analysis) {
            const timestamp = new Date().toLocaleString();

            const alertDiv = document.createElement('div');
            alertDiv.className = 'alert-box';
            alertDiv.innerHTML = `
                <div class="alert-title">ğŸš¨ğŸš¨ğŸš¨ MEDICAL ALERT - NURSE ASSISTANCE REQUIRED ğŸš¨ğŸš¨ğŸš¨</div>
                <div class="alert-details">
                    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•<br>
                    Patient ID:      ${PATIENT.patientId}<br>
                    Condition:       ${analysis.condition}<br>
                    Confidence:      ${(analysis.confidence * 100).toFixed(1)}%<br>
                    Urgency:         ${analysis.urgency.toUpperCase()}<br>
                    Time:            ${timestamp}<br>
                    <br>
                    Description:<br>
                    ${analysis.description}<br>
                    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•<br>
                    <br>
                    ğŸ“± Notification sent to nurse station
                </div>
            `;

            output.insertBefore(alertDiv, output.firstChild);

            setTimeout(() => {
                alertDiv.style.opacity = '0.3';
            }, 30000);
        }

        window.addEventListener('beforeunload', async () => {
            stopHeartbeat();
            closePeerConnection();
            stopCameraStream();
            
            // Cleanup LiveKit
            if (livekitRoom) {
                await livekitRoom.disconnect();
                livekitRoom = null;
            }
            
            if (vision) {
                await vision.stop();
            }
            ws?.close();
        });

        async function initCameraStream() {
            if (!navigator.mediaDevices?.getUserMedia) {
                throw new Error('Camera API unavailable');
            }

            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: 640 },
                    height: { ideal: 360 },
                    frameRate: { ideal: 15 },
                },
                audio: false,
            });

            if (previewVideo) {
                previewVideo.srcObject = stream;
                await previewVideo.play().catch(() => {});
            }

            return stream;
        }

        async function startVideoStreaming() {
            try {
                if (!cameraStream) {
                    cameraStream = await initCameraStream();
                }
            } catch (error) {
                console.error('Failed to start video streaming', error);
            }
        }

        function stopVideoStreaming() {
            closePeerConnection();
        }

        function stopCameraStream() {
            cameraStream?.getTracks().forEach((track) => track.stop());
            cameraStream = null;
        }

        async function handleWebRtcOffer(message) {
            try {
                if (!cameraStream) {
                    cameraStream = await initCameraStream();
                }

                const pc = await setupPeerConnection(message.nurseId);
                await pc.setRemoteDescription(new RTCSessionDescription(message.offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                ws?.send(
                    JSON.stringify({
                        type: 'webrtc_answer',
                        patientId: PATIENT.patientId,
                        nurseId: message.nurseId,
                        answer,
                    })
                );

                flushPendingRemoteCandidates();
            } catch (error) {
                console.error('Failed to process WebRTC offer', error);
            }
        }

        async function setupPeerConnection(nurseId) {
            if (peerConnection && currentNurseId === nurseId) {
                return peerConnection;
            }

            closePeerConnection();

            peerConnection = new RTCPeerConnection(rtcConfig);
            currentNurseId = nurseId;

            cameraStream?.getTracks().forEach((track) => {
                peerConnection?.addTrack(track, cameraStream);
            });

            peerConnection.onicecandidate = (event) => {
                if (event.candidate && ws?.readyState === WebSocket.OPEN) {
                    ws.send(
                        JSON.stringify({
                            type: 'webrtc_ice_candidate',
                            target: 'nurse',
                            patientId: PATIENT.patientId,
                            nurseId: currentNurseId,
                            candidate: event.candidate,
                        })
                    );
                }
            };

            peerConnection.onconnectionstatechange = () => {
                if (!peerConnection) {
                    return;
                }

                if (['failed', 'disconnected', 'closed'].includes(peerConnection.connectionState)) {
                    console.warn('Peer connection state:', peerConnection.connectionState);
                }
            };

            return peerConnection;
        }

        function handleRemoteIceCandidate(message) {
            if (!message.candidate) {
                return;
            }

            if (!peerConnection || !peerConnection.remoteDescription) {
                pendingRemoteCandidates.push(message.candidate);
                return;
            }

            peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate)).catch((error) => {
                console.error('Failed to add remote ICE candidate', error);
            });
        }

        function flushPendingRemoteCandidates() {
            if (!peerConnection || !peerConnection.remoteDescription) {
                return;
            }

            while (pendingRemoteCandidates.length) {
                const candidate = pendingRemoteCandidates.shift();
                if (!candidate) {
                    continue;
                }

                peerConnection.addIceCandidate(new RTCIceCandidate(candidate)).catch((error) => {
                    console.error('Failed to add queued ICE candidate', error);
                });
            }
        }

        function closePeerConnection() {
            if (peerConnection) {
                peerConnection.onicecandidate = null;
                peerConnection.onconnectionstatechange = null;
                peerConnection.close();
            }
            peerConnection = null;
            currentNurseId = null;
            pendingRemoteCandidates.length = 0;
        }

        function normalizeBaseUrl(value) {
            if (!value || typeof value !== 'string') {
                return null;
            }
            return value.trim().replace(/\/$/, '');
        }

        function readConfiguredBackendUrl() {
            const globals = [
                window.MONITOR_BACKEND_URL,
                window.MONITOR_CONFIG && window.MONITOR_CONFIG.backendUrl,
                document.body && document.body.getAttribute('data-backend-url'),
            ];

            for (const candidate of globals) {
                const normalized = normalizeBaseUrl(candidate);
                if (normalized) {
                    return normalized;
                }
            }

            const meta = document.querySelector('meta[name="monitor-backend-url"]');
            if (meta) {
                const normalized = normalizeBaseUrl(meta.getAttribute('content'));
                if (normalized) {
                    return normalized;
                }
            }

            return null;
        }

        function readConfiguredWebsocketUrl() {
            const globals = [
                window.MONITOR_WEBSOCKET_URL,
                window.MONITOR_CONFIG && (window.MONITOR_CONFIG.websocketUrl || window.MONITOR_CONFIG.wsUrl),
                document.body && document.body.getAttribute('data-websocket-url'),
            ];

            for (const candidate of globals) {
                const normalized = normalizeBaseUrl(candidate);
                if (normalized) {
                    return normalized;
                }
            }

            const meta = document.querySelector('meta[name="monitor-websocket-url"]');
            if (meta) {
                const normalized = normalizeBaseUrl(meta.getAttribute('content'));
                if (normalized) {
                    return normalized;
                }
            }

            return null;
        }

        function getHttpBase() {
            const configuredBackend = readConfiguredBackendUrl();
            if (configuredBackend) {
                return configuredBackend;
            }

            const params = new URLSearchParams(window.location.search);
            const backendParam = normalizeBaseUrl(params.get('backend'));
            if (backendParam) {
                return backendParam;
            }

            if (window.location.origin.startsWith('http')) {
                if (window.location.hostname && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                    return window.location.origin;
                }

                if (window.location.port === '3000') {
                    return window.location.origin;
                }
            }

            return 'http://localhost:3000';
        }

        function getWsUrl(httpBaseUrl) {
            const configuredWs = readConfiguredWebsocketUrl();
            if (configuredWs) {
                return configuredWs;
            }

            try {
                const url = new URL(httpBaseUrl);
                const scheme = url.protocol === 'https:' ? 'wss:' : 'ws:';
                return `${scheme}//${url.host}`;
            } catch {
                return 'ws://localhost:3000';
            }
        }

        function buildRtcConfig() {
            const resolved = resolveIceServers();
            const deduped = dedupeIceServers(resolved);
            const limited = deduped.slice(0, 4);
            const iceServers = limited.length ? limited : DEFAULT_ICE_SERVERS;

            return {
                iceServers,
            };
        }

        function resolveIceServers() {
            const configured = readConfiguredIceServers();
            if (configured.length) {
                return configured;
            }
            return DEFAULT_ICE_SERVERS;
        }

        function readConfiguredIceServers() {
            const params = new URLSearchParams(window.location.search);
            const metaTurn = document.querySelector('meta[name="monitor-turn-servers"]');
            const sources = [
                window.MONITOR_CONFIG && (window.MONITOR_CONFIG.iceServers || window.MONITOR_CONFIG.turnServers),
                document.body && document.body.getAttribute('data-turn-servers'),
                metaTurn ? metaTurn.getAttribute('content') : null,
                params.get('turn'),
            ];

            for (const source of sources) {
                const parsed = parseIceServers(source);
                if (parsed.length) {
                    return parsed;
                }
            }

            return [];
        }

        function parseIceServers(value) {
            if (!value) {
                return [];
            }

            if (Array.isArray(value)) {
                return value
                    .map((entry) => normalizeIceServer(entry))
                    .filter((entry) => entry !== null);
            }

            if (typeof value === 'object') {
                const normalized = normalizeIceServer(value);
                return normalized ? [normalized] : [];
            }

            if (typeof value === 'string') {
                const trimmed = value.trim();
                if (!trimmed) {
                    return [];
                }

                if (trimmed.startsWith('[')) {
                    try {
                        const parsed = JSON.parse(trimmed);
                        return parseIceServers(parsed);
                    } catch (error) {
                        console.warn('Failed to parse JSON ice server config', error);
                        return [];
                    }
                }

                const urls = trimmed
                    .split(',')
                    .map((entry) => entry.trim())
                    .filter(Boolean);

                if (urls.length) {
                    return [{ urls }];
                }

                return [];
            }

            return [];
        }

        function normalizeIceServer(entry) {
            if (!entry) {
                return null;
            }

            if (typeof entry === 'string') {
                return { urls: entry };
            }

            if (Array.isArray(entry)) {
                return { urls: entry };
            }

            if (typeof entry === 'object') {
                const candidate = entry;
                const urls = candidate.urls || candidate.url;
                if (!urls) {
                    return null;
                }

                return {
                    urls,
                    username: candidate.username,
                    credential: candidate.credential,
                };
            }

            return null;
        }

        function dedupeIceServers(servers) {
            const seen = new Set();
            const result = [];

            servers.forEach((server) => {
                if (!server) {
                    return;
                }

                const urls = normalizeUrlsArray(server.urls || server.url);
                if (!urls.length) {
                    return;
                }

                const key = `${urls.sort().join('|')}|${server.username || ''}|${server.credential || ''}`;
                if (seen.has(key)) {
                    return;
                }

                seen.add(key);

                const normalizedServer = {
                    urls: urls.length === 1 ? urls[0] : urls,
                };

                if (server.username) {
                    normalizedServer.username = server.username;
                }
                if (server.credential) {
                    normalizedServer.credential = server.credential;
                }

                result.push(normalizedServer);
            });

            return result;
        }

        function normalizeUrlsArray(candidate) {
            if (!candidate) {
                return [];
            }

            if (Array.isArray(candidate)) {
                return candidate.map((url) => url?.trim()).filter(Boolean);
            }

            if (typeof candidate === 'string') {
                return candidate
                    .split(',')
                    .map((url) => url.trim())
                    .filter(Boolean);
            }

            return [];
        }
    </script>
</body>

</html>